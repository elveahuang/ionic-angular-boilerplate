import{a as ge,c as ye,e as P}from"./chunk-XD4PSF4R.js";var n={allRenderFn:!1,cmpDidLoad:!0,cmpDidUnload:!1,cmpDidUpdate:!0,cmpDidRender:!0,cmpWillLoad:!0,cmpWillUpdate:!0,cmpWillRender:!0,connectedCallback:!0,disconnectedCallback:!0,element:!0,event:!0,hasRenderFn:!0,lifecycle:!0,hostListener:!0,hostListenerTargetWindow:!0,hostListenerTargetDocument:!0,hostListenerTargetBody:!0,hostListenerTargetParent:!1,hostListenerTarget:!0,member:!0,method:!0,mode:!0,observeAttribute:!0,prop:!0,propMutable:!0,reflect:!0,scoped:!0,shadowDom:!0,slot:!0,cssAnnotations:!0,state:!0,style:!0,formAssociated:!1,svg:!0,updatable:!0,vdomAttribute:!0,vdomXlink:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomRef:!0,vdomPropOrAttr:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,watchCallback:!0,taskQueue:!0,hotModuleReplacement:!1,isDebug:!1,isDev:!1,isTesting:!1,hydrateServerSide:!1,hydrateClientSide:!1,lifecycleDOMEvents:!1,lazyLoad:!1,profile:!1,slotRelocation:!0,appendChildSlotFix:!1,cloneNodeFix:!1,hydratedAttribute:!1,hydratedClass:!0,scriptDataOpts:!1,scopedSlotTextContentFix:!1,shadowDomShim:!1,slotChildNodesFix:!1,invisiblePrehydration:!0,propBoolean:!0,propNumber:!0,propString:!0,constructableCSS:!0,cmpShouldUpdate:!0,devTools:!1,shadowDelegatesFocus:!0,initializeNextTick:!1,asyncLoading:!1,asyncQueue:!1,transformTagName:!1,attachStyles:!0,experimentalSlotFixes:!1};var F="app";var dt=ye({});var ft=Object.defineProperty,ut=(e,t)=>{for(var s in t)ft(e,s,{get:t[s],enumerable:!0})},bs={isDev:!!n.isDev,isBrowser:!0,isServer:!1,isTesting:!!n.isTesting},Ds=e=>{let t=new URL(e,h.$resourcesUrl$);return t.origin!==O.location.origin?t.href:t.pathname};var Se={},pt="http://www.w3.org/2000/svg",ht="http://www.w3.org/1999/xhtml",mt=e=>e!=null,fe=e=>(e=typeof e,e==="object"||e==="function");function vt(e){var t,s,o;return(o=(s=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:s.getAttribute("content"))!=null?o:void 0}var gt={};ut(gt,{err:()=>Pe,map:()=>yt,ok:()=>se,unwrap:()=>St,unwrapErr:()=>Lt});var se=e=>({isOk:!0,isErr:!1,value:e}),Pe=e=>({isOk:!1,isErr:!0,value:e});function yt(e,t){if(e.isOk){let s=t(e.value);return s instanceof Promise?s.then(o=>se(o)):se(s)}if(e.isErr){let s=e.value;return Pe(s)}throw"should never get here"}var St=e=>{if(e.isOk)return e.value;throw e.value},Lt=e=>{if(e.isErr)return e.value;throw e.value},bt=0,I=(e,t="")=>{if(n.profile&&performance.mark){let s=`st:${e}:${t}:${bt++}`;return performance.mark(s),()=>performance.measure(`[Stencil] ${e}() <${t}>`,s)}else return()=>{}},xt=(e,t)=>n.profile&&performance.mark?(performance.getEntriesByName(e,"mark").length===0&&performance.mark(e),()=>{performance.getEntriesByName(t,"measure").length===0&&performance.measure(t,e)}):()=>{};var Dt="r",Tt="o",Ct="s",It="t",ne="s-id",Le="sty-id",be="c-id";var Nt="slot-fb{display:contents}slot-fb[hidden]{display:none}",xe="http://www.w3.org/1999/xlink",kt=["formAssociatedCallback","formResetCallback","formDisabledCallback","formStateRestoreCallback"],Fe=(e,t,...s)=>{let o=null,r=null,i=null,a=!1,c=!1,l=[],$=f=>{for(let p=0;p<f.length;p++)o=f[p],Array.isArray(o)?$(o):o!=null&&typeof o!="boolean"&&((a=typeof e!="function"&&!fe(o))?o=String(o):n.isDev&&typeof e!="function"&&o.$flags$===void 0&&Q(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`),a&&c?l[l.length-1].$text$+=o:l.push(a?R(null,o):o),c=a)};if($(s),t&&(n.isDev&&e==="input"&&Et(t),n.vdomKey&&t.key&&(r=t.key),n.slotRelocation&&t.name&&(i=t.name),n.vdomClass)){let f=t.className||t.class;f&&(t.class=typeof f!="object"?f:Object.keys(f).filter(p=>f[p]).join(" "))}if(n.isDev&&l.some(oe)&&Q(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`),n.vdomFunctional&&typeof e=="function")return e(t===null?{}:t,l,_t);let d=R(e,null);return d.$attrs$=t,l.length>0&&(d.$children$=l),n.vdomKey&&(d.$key$=r),n.slotRelocation&&(d.$name$=i),d},R=(e,t)=>{let s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return n.vdomAttribute&&(s.$attrs$=null),n.vdomKey&&(s.$key$=null),n.slotRelocation&&(s.$name$=null),s},At={},oe=e=>e&&e.$tag$===At,_t={forEach:(e,t)=>e.map(De).forEach(t),map:(e,t)=>e.map(De).map(t).map(wt)},De=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),wt=e=>{if(typeof e.vtag=="function"){let s=ge({},e.vattrs);return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),Fe(e.vtag,s,...e.vchildren||[])}let t=R(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},Et=e=>{let t=Object.keys(e),s=t.indexOf("value");if(s===-1)return;let o=t.indexOf("type"),r=t.indexOf("min"),i=t.indexOf("max"),a=t.indexOf("step");(s<o||s<r||s<i||s<a)&&z('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},Ut=(e,t,s,o)=>{let r=I("hydrateClient",t),i=e.shadowRoot,a=[],c=[],l=n.shadowDom&&i?[]:null,$=o.$vnode$=R(t,null);h.$orgLocNodes$||ie(v.body,h.$orgLocNodes$=new Map),e[ne]=s,e.removeAttribute(ne),re($,a,c,l,e,e,s),a.map(d=>{let f=d.$hostId$+"."+d.$nodeId$,p=h.$orgLocNodes$.get(f),u=d.$elm$;p&&_&&p["s-en"]===""&&p.parentNode.insertBefore(u,p.nextSibling),i||(u["s-hn"]=t,p&&(u["s-ol"]=p,u["s-ol"]["s-nr"]=u)),h.$orgLocNodes$.delete(f)}),n.shadowDom&&i&&l.map(d=>{d&&i.appendChild(d)}),r()},re=(e,t,s,o,r,i,a)=>{let c,l,$,d;if(i.nodeType===1){for(c=i.getAttribute(be),c&&(l=c.split("."),(l[0]===a||l[0]==="0")&&($={$flags$:0,$hostId$:l[0],$nodeId$:l[1],$depth$:l[2],$index$:l[3],$tag$:i.tagName.toLowerCase(),$elm$:i,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null},t.push($),i.removeAttribute(be),e.$children$||(e.$children$=[]),e.$children$[$.$index$]=$,e=$,o&&$.$depth$==="0"&&(o[$.$index$]=$.$elm$))),d=i.childNodes.length-1;d>=0;d--)re(e,t,s,o,r,i.childNodes[d],a);if(i.shadowRoot)for(d=i.shadowRoot.childNodes.length-1;d>=0;d--)re(e,t,s,o,r,i.shadowRoot.childNodes[d],a)}else if(i.nodeType===8)l=i.nodeValue.split("."),(l[1]===a||l[1]==="0")&&(c=l[0],$={$flags$:0,$hostId$:l[1],$nodeId$:l[2],$depth$:l[3],$index$:l[4],$elm$:i,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null},c===It?($.$elm$=i.nextSibling,$.$elm$&&$.$elm$.nodeType===3&&($.$text$=$.$elm$.textContent,t.push($),i.remove(),e.$children$||(e.$children$=[]),e.$children$[$.$index$]=$,o&&$.$depth$==="0"&&(o[$.$index$]=$.$elm$))):$.$hostId$===a&&(c===Ct?($.$tag$="slot",l[5]?i["s-sn"]=$.$name$=l[5]:i["s-sn"]="",i["s-sr"]=!0,n.shadowDom&&o&&($.$elm$=v.createElement($.$tag$),$.$name$&&$.$elm$.setAttribute("name",$.$name$),i.parentNode.insertBefore($.$elm$,i),i.remove(),$.$depth$==="0"&&(o[$.$index$]=$.$elm$)),s.push($),e.$children$||(e.$children$=[]),e.$children$[$.$index$]=$):c===Dt&&(n.shadowDom&&o?i.remove():n.slotRelocation&&(r["s-cr"]=i,i["s-cn"]=!0))));else if(e&&e.$tag$==="style"){let f=R(null,i.textContent);f.$elm$=i,f.$index$="0",e.$children$=[f]}},ie=(e,t)=>{if(e.nodeType===1){let s=0;for(;s<e.childNodes.length;s++)ie(e.childNodes[s],t);if(e.shadowRoot)for(s=0;s<e.shadowRoot.childNodes.length;s++)ie(e.shadowRoot.childNodes[s],t)}else if(e.nodeType===8){let s=e.nodeValue.split(".");s[0]===Tt&&(t.set(s[1]+"."+s[2],e),e.nodeValue="",e["s-en"]=s[3])}},Rt=e=>ct.map(t=>t(e)).find(t=>!!t),_s=e=>ct.push(e),ws=e=>x(e).$modeName$,Bt=(e,t)=>e!=null&&!fe(e)?n.propBoolean&&t&4?e==="false"?!1:e===""||!!e:n.propNumber&&t&2?parseFloat(e):n.propString&&t&1?String(e):e:e,Ot=e=>n.lazyLoad?x(e).$hostElement$:e,zs=(e,t,s)=>{let o=Ot(e);return{emit:r=>(n.isDev&&!o.isConnected&&z(`The "${t}" event was emitted, but the dispatcher node is no longer connected to the dom.`),ue(o,t,{bubbles:!!(s&4),composed:!!(s&2),cancelable:!!(s&1),detail:r}))}},ue=(e,t,s)=>{let o=h.ce(t,s);return e.dispatchEvent(o),o},Te=new WeakMap,jt=(e,t,s)=>{let o=X.get(e);ms&&s?(o=o||new CSSStyleSheet,typeof o=="string"?o=t:o.replaceSync(t)):o=t,X.set(e,o)},ae=(e,t,s)=>{var o;let r=He(t,s),i=X.get(r);if(!n.attachStyles)return r;if(e=e.nodeType===11?e:v,i)if(typeof i=="string"){e=e.head||e;let a=Te.get(e),c;if(a||Te.set(e,a=new Set),!a.has(r)){if(n.hydrateClientSide&&e.host&&(c=e.querySelector(`[${Le}="${r}"]`)))c.innerHTML=i;else{c=v.createElement("style"),c.innerHTML=i;let l=(o=h.$nonce$)!=null?o:vt(v);l!=null&&c.setAttribute("nonce",l),(n.hydrateServerSide||n.hotModuleReplacement)&&c.setAttribute(Le,r),e.insertBefore(c,e.querySelector("link"))}t.$flags$&4&&(c.innerHTML+=Nt),a&&a.add(r)}}else n.constructableCSS&&!e.adoptedStyleSheets.includes(i)&&(e.adoptedStyleSheets=[...e.adoptedStyleSheets,i]);return r},zt=e=>{let t=e.$cmpMeta$,s=e.$hostElement$,o=t.$flags$,r=I("attachStyles",t.$tagName$),i=ae(n.shadowDom&&_&&s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);(n.shadowDom||n.scoped)&&n.cssAnnotations&&o&10&&(s["s-sc"]=i,s.classList.add(i+"-h"),n.scoped&&o&2&&s.classList.add(i+"-s")),r()},He=(e,t)=>"sc-"+(n.mode&&t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$);var Ce=(e,t,s,o,r,i)=>{if(s!==o){let a=Be(e,t),c=t.toLowerCase();if(n.vdomClass&&t==="class"){let l=e.classList,$=Ie(s),d=Ie(o);l.remove(...$.filter(f=>f&&!d.includes(f))),l.add(...d.filter(f=>f&&!$.includes(f)))}else if(n.vdomStyle&&t==="style"){if(n.updatable)for(let l in s)(!o||o[l]==null)&&(!n.hydrateServerSide&&l.includes("-")?e.style.removeProperty(l):e.style[l]="");for(let l in o)(!s||o[l]!==s[l])&&(!n.hydrateServerSide&&l.includes("-")?e.style.setProperty(l,o[l]):e.style[l]=o[l])}else if(!(n.vdomKey&&t==="key")){if(n.vdomRef&&t==="ref")o&&o(e);else if(n.vdomListener&&(n.lazyLoad?!a:!e.__lookupSetter__(t))&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"?t=t.slice(3):Be(O,c)?t=c.slice(2):t=c[2]+t.slice(3),s||o){let l=t.endsWith(Me);t=t.replace(Ft,""),s&&h.rel(e,t,s,l),o&&h.ael(e,t,o,l)}}else if(n.vdomPropOrAttr){let l=fe(o);if((a||l&&o!==null)&&!r)try{if(e.tagName.includes("-"))e[t]=o;else{let d=o??"";t==="list"?a=!1:(s==null||e[t]!=d)&&(e[t]=d)}}catch{}let $=!1;n.vdomXlink&&c!==(c=c.replace(/^xlink\:?/,""))&&(t=c,$=!0),o==null||o===!1?(o!==!1||e.getAttribute(t)==="")&&(n.vdomXlink&&$?e.removeAttributeNS(xe,t):e.removeAttribute(t)):(!a||i&4||r)&&!l&&(o=o===!0?"":o,n.vdomXlink&&$?e.setAttributeNS(xe,t,o):e.setAttribute(t,o))}}}},Pt=/\s/,Ie=e=>e?e.split(Pt):[],Me="Capture",Ft=new RegExp(Me+"$"),We=(e,t,s)=>{let o=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,r=e&&e.$attrs$||Se,i=t.$attrs$||Se;if(n.updatable)for(let a of Ne(Object.keys(r)))a in i||Ce(o,a,r[a],void 0,s,t.$flags$);for(let a of Ne(Object.keys(i)))Ce(o,a,r[a],i[a],s,t.$flags$)};function Ne(e){return e.includes("ref")?[...e.filter(t=>t!=="ref"),"ref"]:e}var w,le,C,pe=!1,W=!1,G=!1,b=!1,q=(e,t,s,o)=>{var r;let i=t.$children$[s],a=0,c,l,$;if(n.slotRelocation&&!pe&&(G=!0,i.$tag$==="slot"&&(w&&o.classList.add(w+"-s"),i.$flags$|=i.$children$?2:1)),n.isDev&&i.$elm$&&Q(`The JSX ${i.$text$!==null?`"${i.$text$}" text`:`"${i.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),n.vdomText&&i.$text$!==null)c=i.$elm$=v.createTextNode(i.$text$);else if(n.slotRelocation&&i.$flags$&1)c=i.$elm$=n.isDebug||n.hydrateServerSide?Wt(i):v.createTextNode("");else{if(n.svg&&!b&&(b=i.$tag$==="svg"),c=i.$elm$=n.svg?v.createElementNS(b?pt:ht,n.slotRelocation&&i.$flags$&2?"slot-fb":i.$tag$):v.createElement(n.slotRelocation&&i.$flags$&2?"slot-fb":i.$tag$),n.svg&&b&&i.$tag$==="foreignObject"&&(b=!1),n.vdomAttribute&&We(null,i,b),(n.shadowDom||n.scoped)&&mt(w)&&c["s-si"]!==w&&c.classList.add(c["s-si"]=w),i.$children$)for(a=0;a<i.$children$.length;++a)l=q(e,i,a,c),l&&c.appendChild(l);n.svg&&(i.$tag$==="svg"?b=!1:c.tagName==="foreignObject"&&(b=!0))}return c["s-hn"]=C,n.slotRelocation&&i.$flags$&3&&(c["s-sr"]=!0,c["s-cr"]=le,c["s-sn"]=i.$name$||"",c["s-rf"]=(r=i.$attrs$)==null?void 0:r.ref,$=e&&e.$children$&&e.$children$[s],$&&$.$tag$===i.$tag$&&e.$elm$&&(n.experimentalSlotFixes?qe(e.$elm$):j(e.$elm$,!1))),c},qe=e=>{h.$flags$|=1;let t=e.closest(C.toLowerCase());if(t!=null){let s=Array.from(t.childNodes).find(r=>r["s-cr"]),o=Array.from(e.childNodes);for(let r of s?o.reverse():o)r["s-sh"]!=null&&(L(t,r,s??null),r["s-sh"]=void 0,G=!0)}h.$flags$&=-2},j=(e,t)=>{h.$flags$|=1;let s=Array.from(e.childNodes);if(e["s-sr"]&&n.experimentalSlotFixes){let o=e;for(;o=o.nextSibling;)o&&o["s-sn"]===e["s-sn"]&&o["s-sh"]===C&&s.push(o)}for(let o=s.length-1;o>=0;o--){let r=s[o];r["s-hn"]!==C&&r["s-ol"]&&(L(Ke(r),r,he(r)),r["s-ol"].remove(),r["s-ol"]=void 0,r["s-sh"]=void 0,G=!0),t&&j(r,t)}h.$flags$&=-2},Qe=(e,t,s,o,r,i)=>{let a=n.slotRelocation&&e["s-cr"]&&e["s-cr"].parentNode||e,c;for(n.shadowDom&&a.shadowRoot&&a.tagName===C&&(a=a.shadowRoot);r<=i;++r)o[r]&&(c=q(null,s,r,e),c&&(o[r].$elm$=c,L(a,c,n.slotRelocation?he(t):t)))},Xe=(e,t,s)=>{for(let o=t;o<=s;++o){let r=e[o];if(r){let i=r.$elm$;Ge(r),i&&(n.slotRelocation&&(W=!0,i["s-ol"]?i["s-ol"].remove():j(i,!0)),i.remove())}}},Ht=(e,t,s,o,r=!1)=>{let i=0,a=0,c=0,l=0,$=t.length-1,d=t[0],f=t[$],p=o.length-1,u=o[0],m=o[p],y,g;for(;i<=$&&a<=p;)if(d==null)d=t[++i];else if(f==null)f=t[--$];else if(u==null)u=o[++a];else if(m==null)m=o[--p];else if(H(d,u,r))E(d,u,r),d=t[++i],u=o[++a];else if(H(f,m,r))E(f,m,r),f=t[--$],m=o[--p];else if(H(d,m,r))n.slotRelocation&&(d.$tag$==="slot"||m.$tag$==="slot")&&j(d.$elm$.parentNode,!1),E(d,m,r),L(e,d.$elm$,f.$elm$.nextSibling),d=t[++i],m=o[--p];else if(H(f,u,r))n.slotRelocation&&(d.$tag$==="slot"||m.$tag$==="slot")&&j(f.$elm$.parentNode,!1),E(f,u,r),L(e,f.$elm$,d.$elm$),f=t[--$],u=o[++a];else{if(c=-1,n.vdomKey){for(l=i;l<=$;++l)if(t[l]&&t[l].$key$!==null&&t[l].$key$===u.$key$){c=l;break}}n.vdomKey&&c>=0?(g=t[c],g.$tag$!==u.$tag$?y=q(t&&t[a],s,c,e):(E(g,u,r),t[c]=void 0,y=g.$elm$),u=o[++a]):(y=q(t&&t[a],s,a,e),u=o[++a]),y&&(n.slotRelocation?L(Ke(d.$elm$),y,he(d.$elm$)):L(d.$elm$.parentNode,y,d.$elm$))}i>$?Qe(e,o[p+1]==null?null:o[p+1].$elm$,s,o,a,p):n.updatable&&a>p&&Xe(t,i,$)},H=(e,t,s=!1)=>e.$tag$===t.$tag$?n.slotRelocation&&e.$tag$==="slot"?e.$name$===t.$name$:n.vdomKey&&!s?e.$key$===t.$key$:!0:!1,he=e=>e&&e["s-ol"]||e,Ke=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,E=(e,t,s=!1)=>{let o=t.$elm$=e.$elm$,r=e.$children$,i=t.$children$,a=t.$tag$,c=t.$text$,l;!n.vdomText||c===null?(n.svg&&(b=a==="svg"?!0:a==="foreignObject"?!1:b),(n.vdomAttribute||n.reflect)&&(n.slot&&a==="slot"&&!pe?n.experimentalSlotFixes&&e.$name$!==t.$name$&&(t.$elm$["s-sn"]=t.$name$||"",qe(t.$elm$.parentElement)):We(e,t,b)),n.updatable&&r!==null&&i!==null?Ht(o,r,t,i,s):i!==null?(n.updatable&&n.vdomText&&e.$text$!==null&&(o.textContent=""),Qe(o,null,t,i,0,i.length-1)):n.updatable&&r!==null&&Xe(r,0,r.length-1),n.svg&&b&&a==="svg"&&(b=!1)):n.vdomText&&n.slotRelocation&&(l=o["s-cr"])?l.parentNode.textContent=c:n.vdomText&&e.$text$!==c&&(o.data=c)},J=e=>{let t=e.childNodes;for(let s of t)if(s.nodeType===1){if(s["s-sr"]){let o=s["s-sn"];s.hidden=!1;for(let r of t)if(r!==s){if(r["s-hn"]!==s["s-hn"]||o!==""){if(r.nodeType===1&&(o===r.getAttribute("slot")||o===r["s-sn"])||r.nodeType===3&&o===r["s-sn"]){s.hidden=!0;break}}else if(r.nodeType===1||r.nodeType===3&&r.textContent.trim()!==""){s.hidden=!0;break}}}J(s)}},T=[],Ye=e=>{let t,s,o;for(let r of e.childNodes){if(r["s-sr"]&&(t=r["s-cr"])&&t.parentNode){s=t.parentNode.childNodes;let i=r["s-sn"];for(o=s.length-1;o>=0;o--)if(t=s[o],!t["s-cn"]&&!t["s-nr"]&&t["s-hn"]!==r["s-hn"]&&(!n.experimentalSlotFixes||!t["s-sh"]||t["s-sh"]!==r["s-hn"]))if(ke(t,i)){let a=T.find(c=>c.$nodeToRelocate$===t);W=!0,t["s-sn"]=t["s-sn"]||i,a?(a.$nodeToRelocate$["s-sh"]=r["s-hn"],a.$slotRefNode$=r):(t["s-sh"]=r["s-hn"],T.push({$slotRefNode$:r,$nodeToRelocate$:t})),t["s-sr"]&&T.map(c=>{ke(c.$nodeToRelocate$,t["s-sn"])&&(a=T.find(l=>l.$nodeToRelocate$===t),a&&!c.$slotRefNode$&&(c.$slotRefNode$=a.$slotRefNode$))})}else T.some(a=>a.$nodeToRelocate$===t)||T.push({$nodeToRelocate$:t})}r.nodeType===1&&Ye(r)}},ke=(e,t)=>e.nodeType===1?e.getAttribute("slot")===null&&t===""||e.getAttribute("slot")===t:e["s-sn"]===t?!0:t==="",Ge=e=>{n.vdomRef&&(e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(Ge))},L=(e,t,s)=>{let o=e==null?void 0:e.insertBefore(t,s);return n.scoped&&Mt(t,e),o},Je=e=>e?e["s-rsc"]||e["s-si"]||e["s-sc"]||Je(e.parentElement):void 0,Mt=(e,t)=>{var s,o,r;if(e&&t){let i=e["s-rsc"],a=Je(t);i&&((s=e.classList)!=null&&s.contains(i))&&e.classList.remove(i),a&&(e["s-rsc"]=a,!((o=e.classList)!=null&&o.contains(a))&&((r=e.classList)==null||r.add(a)))}},Ae=(e,t,s=!1)=>{var o,r,i,a,c;let l=e.$hostElement$,$=e.$cmpMeta$,d=e.$vnode$||R(null,null),f=oe(t)?t:Fe(null,null,t);if(C=l.tagName,n.isDev&&Array.isArray(t)&&t.some(oe))throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${C.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);if(n.reflect&&$.$attrsToReflect$&&(f.$attrs$=f.$attrs$||{},$.$attrsToReflect$.map(([p,u])=>f.$attrs$[u]=l[p])),s&&f.$attrs$)for(let p of Object.keys(f.$attrs$))l.hasAttribute(p)&&!["key","ref","style","class"].includes(p)&&(f.$attrs$[p]=l[p]);if(f.$tag$=null,f.$flags$|=4,e.$vnode$=f,f.$elm$=d.$elm$=n.shadowDom&&l.shadowRoot||l,(n.scoped||n.shadowDom)&&(w=l["s-sc"]),pe=_&&($.$flags$&1)!==0,n.slotRelocation&&(le=l["s-cr"],W=!1),E(d,f,s),n.slotRelocation){if(h.$flags$|=1,G){Ye(f.$elm$);for(let p of T){let u=p.$nodeToRelocate$;if(!u["s-ol"]){let m=n.isDebug||n.hydrateServerSide?qt(u):v.createTextNode("");m["s-nr"]=u,L(u.parentNode,u["s-ol"]=m,u)}}for(let p of T){let u=p.$nodeToRelocate$,m=p.$slotRefNode$;if(m){let y=m.parentNode,g=m.nextSibling;if(!n.experimentalSlotFixes||g&&g.nodeType===1){let k=(o=u["s-ol"])==null?void 0:o.previousSibling;for(;k;){let S=(r=k["s-nr"])!=null?r:null;if(S&&S["s-sn"]===u["s-sn"]&&y===S.parentNode){for(S=S.nextSibling;S===u||S!=null&&S["s-sr"];)S=S==null?void 0:S.nextSibling;if(!S||!S["s-nr"]){g=S;break}}k=k.previousSibling}}(!g&&y!==u.parentNode||u.nextSibling!==g)&&u!==g&&(!n.experimentalSlotFixes&&!u["s-hn"]&&u["s-ol"]&&(u["s-hn"]=u["s-ol"].parentNode.nodeName),L(y,u,g),u.nodeType===1&&(u.hidden=(i=u["s-ih"])!=null?i:!1)),u&&typeof m["s-rf"]=="function"&&m["s-rf"](u)}else u.nodeType===1&&(s&&(u["s-ih"]=(a=u.hidden)!=null?a:!1),u.hidden=!0)}}W&&J(f.$elm$),h.$flags$&=-2,T.length=0}if(n.experimentalScopedSlotChanges&&$.$flags$&2)for(let p of f.$elm$.childNodes)p["s-hn"]!==C&&!p["s-sh"]&&(s&&p["s-ih"]==null&&(p["s-ih"]=(c=p.hidden)!=null?c:!1),p.hidden=!0);le=void 0},Wt=e=>v.createComment(`<slot${e.$name$?' name="'+e.$name$+'"':""}> (host=${C.toLowerCase()})`),qt=e=>v.createComment("org-location for "+(e.localName?`<${e.localName}> (host=${e["s-hn"]})`:`[${e.textContent}]`)),Ze=(e,t)=>{n.asyncLoading&&t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise(s=>e.$onRenderResolve$=s))},me=(e,t)=>{if(n.taskQueue&&n.updatable&&(e.$flags$|=16),n.asyncLoading&&e.$flags$&4){e.$flags$|=512;return}Ze(e,e.$ancestorComponent$);let s=()=>Qt(e,t);return n.taskQueue?vs(s):s()},Qt=(e,t)=>{let s=e.$hostElement$,o=I("scheduleUpdate",e.$cmpMeta$.$tagName$),r=n.lazyLoad?e.$lazyInstance$:s,i;return t?(n.lazyLoad&&n.hostListener&&(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map(([a,c])=>D(r,a,c)),e.$queuedListeners$=void 0)),U(s,"componentWillLoad"),n.cmpWillLoad&&(i=D(r,"componentWillLoad"))):(U(s,"componentWillUpdate"),n.cmpWillUpdate&&(i=D(r,"componentWillUpdate"))),U(s,"componentWillRender"),n.cmpWillRender&&(i=_e(i,()=>D(r,"componentWillRender"))),o(),_e(i,()=>Kt(e,r,t))},_e=(e,t)=>Xt(e)?e.then(t):t(),Xt=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",Kt=(e,t,s)=>P(void 0,null,function*(){var o;let r=e.$hostElement$,i=I("update",e.$cmpMeta$.$tagName$),a=r["s-rc"];n.style&&s&&zt(e);let c=I("render",e.$cmpMeta$.$tagName$);if(n.isDev&&(e.$flags$|=1024),n.hydrateServerSide?yield Ee(e,t,r,s):Ee(e,t,r,s),n.isDev&&(e.$renderCount$=e.$renderCount$===void 0?1:e.$renderCount$+1,e.$flags$&=-1025),n.hydrateServerSide)try{et(r),s&&(e.$cmpMeta$.$flags$&1?r["s-en"]="":e.$cmpMeta$.$flags$&2&&(r["s-en"]="c"))}catch(l){N(l,r)}if(n.asyncLoading&&a&&(a.map(l=>l()),r["s-rc"]=void 0),c(),i(),n.asyncLoading){let l=(o=r["s-p"])!=null?o:[],$=()=>Ue(e);l.length===0?$():(Promise.all(l).then($),e.$flags$|=4,l.length=0)}else Ue(e)}),we=null,Ee=(e,t,s,o)=>{let r=!!n.allRenderFn,i=!!n.lazyLoad,a=!!n.taskQueue,c=!!n.updatable;try{if(we=t,t=(r||t.render)&&t.render(),c&&a&&(e.$flags$&=-17),(c||i)&&(e.$flags$|=2),n.hasRenderFn||n.reflect)if(n.vdomRender||n.reflect){if(n.hydrateServerSide)return Promise.resolve(t).then(l=>Ae(e,l,o));Ae(e,t,o)}else{let l=s.shadowRoot;e.$cmpMeta$.$flags$&1?l.textContent=t:s.textContent=t}}catch(l){N(l,e.$hostElement$)}return we=null,null};var Ue=e=>{let t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,o=I("postUpdate",t),r=n.lazyLoad?e.$lazyInstance$:s,i=e.$ancestorComponent$;n.cmpDidRender&&(n.isDev&&(e.$flags$|=1024),D(r,"componentDidRender"),n.isDev&&(e.$flags$&=-1025)),U(s,"componentDidRender"),e.$flags$&64?(n.cmpDidUpdate&&(n.isDev&&(e.$flags$|=1024),D(r,"componentDidUpdate"),n.isDev&&(e.$flags$&=-1025)),U(s,"componentDidUpdate"),o()):(e.$flags$|=64,n.asyncLoading&&n.cssAnnotations&&Ve(s),n.cmpDidLoad&&(n.isDev&&(e.$flags$|=2048),D(r,"componentDidLoad"),n.isDev&&(e.$flags$&=-2049)),U(s,"componentDidLoad"),o(),n.asyncLoading&&(e.$onReadyResolve$(s),i||Yt(t))),n.method&&n.lazyLoad&&e.$onInstanceResolve$(s),n.asyncLoading&&(e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&Z(()=>me(e,!1)),e.$flags$&=-517)};var Yt=e=>{n.cssAnnotations&&Ve(v.documentElement),n.asyncQueue&&(h.$flags$|=2),Z(()=>ue(O,"appload",{detail:{namespace:F}})),n.profile&&performance.measure&&performance.measure(`[Stencil] ${F} initial load (by ${e})`,"st:app:start")},D=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(o){N(o)}},U=(e,t)=>{n.lifecycleDOMEvents&&ue(e,"stencil_"+t,{bubbles:!0,composed:!0,detail:{namespace:F}})},Ve=e=>n.hydratedClass?e.classList.add("hydrated"):n.hydratedAttribute?e.setAttribute("hydrated",""):void 0,et=e=>{let t=e.children;if(t!=null)for(let s=0,o=t.length;s<o;s++){let r=t[s];typeof r.connectedCallback=="function"&&r.connectedCallback(),et(r)}},Gt=(e,t)=>x(e).$instanceValues$.get(t),Jt=(e,t,s,o)=>{let r=x(e);if(n.lazyLoad&&!r)throw new Error(`Couldn't find host element for "${o.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`);let i=n.lazyLoad?r.$hostElement$:e,a=r.$instanceValues$.get(t),c=r.$flags$,l=n.lazyLoad?r.$lazyInstance$:i;s=Bt(s,o.$members$[t][0]);let $=Number.isNaN(a)&&Number.isNaN(s),d=s!==a&&!$;if((!n.lazyLoad||!(c&8)||a===void 0)&&d&&(r.$instanceValues$.set(t,s),n.isDev&&(r.$flags$&1024?z(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,`
Element`,i,`
New value`,s,`
Old value`,a):r.$flags$&2048&&z(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,`
Element`,i,`
New value`,s,`
Old value`,a)),!n.lazyLoad||l)){if(n.watchCallback&&o.$watchers$&&c&128){let f=o.$watchers$[t];f&&f.map(p=>{try{l[p](s,a,t)}catch(u){N(u,i)}})}if(n.updatable&&(c&18)===2){if(n.cmpShouldUpdate&&l.componentShouldUpdate&&l.componentShouldUpdate(s,a,t)===!1)return;me(r,!1)}}},tt=(e,t,s)=>{var o;let r=e.prototype;if(n.formAssociated&&t.$flags$&64&&s&1&&kt.forEach(i=>Object.defineProperty(r,i,{value(...a){let c=x(this),l=n.lazyLoad?c.$hostElement$:this,$=n.lazyLoad?c.$lazyInstance$:l;if(!$)c.$onReadyPromise$.then(d=>{let f=d[i];typeof f=="function"&&f.call(d,...a)});else{let d=$[i];typeof d=="function"&&d.call($,...a)}}})),n.member&&t.$members$){n.watchCallback&&e.watchers&&(t.$watchers$=e.watchers);let i=Object.entries(t.$members$);if(i.map(([a,[c]])=>{(n.prop||n.state)&&(c&31||(!n.lazyLoad||s&2)&&c&32)?Object.defineProperty(r,a,{get(){return Gt(this,a)},set(l){if(n.isDev){let $=x(this);!(s&1)&&($&&$.$flags$&8)===0&&c&31&&!(c&1024)&&z(`@Prop() "${a}" on <${t.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`)}Jt(this,a,l,t)},configurable:!0,enumerable:!0}):n.lazyLoad&&n.method&&s&1&&c&64&&Object.defineProperty(r,a,{value(...l){var $;let d=x(this);return($=d==null?void 0:d.$onInstancePromise$)==null?void 0:$.then(()=>{var f;return(f=d.$lazyInstance$)==null?void 0:f[a](...l)})}})}),n.observeAttribute&&(!n.lazyLoad||s&1)){let a=new Map;r.attributeChangedCallback=function(c,l,$){h.jmp(()=>{var d;let f=a.get(c);if(this.hasOwnProperty(f))$=this[f],delete this[f];else{if(r.hasOwnProperty(f)&&typeof this[f]=="number"&&this[f]==$)return;if(f==null){let p=x(this),u=p==null?void 0:p.$flags$;if(u&&!(u&8)&&u&128&&$!==l){let m=n.lazyLoad?p.$hostElement$:this,y=n.lazyLoad?p.$lazyInstance$:m,g=(d=t.$watchers$)==null?void 0:d[c];g==null||g.forEach(k=>{y[k]!=null&&y[k].call(y,$,l,c)})}return}}this[f]=$===null&&typeof this[f]=="boolean"?!1:$})},e.observedAttributes=Array.from(new Set([...Object.keys((o=t.$watchers$)!=null?o:{}),...i.filter(([c,l])=>l[0]&15).map(([c,l])=>{var $;let d=l[1]||c;return a.set(d,c),n.reflect&&l[0]&512&&(($=t.$attrsToReflect$)==null||$.push([c,d])),d})]))}}return e},Re=(e,t,s,o)=>P(void 0,null,function*(){let r;if(!(t.$flags$&32)){t.$flags$|=32;let c=s.$lazyBundleId$;if((n.lazyLoad||n.hydrateClientSide)&&c){if(r=us(s,t,o),r.then){let $=xt(`st:load:${s.$tagName$}:${t.$modeName$}`,`[Stencil] Load module for <${s.$tagName$}>`);r=yield r,$()}if((n.isDev||n.isDebug)&&!r)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);n.member&&!r.isProxied&&(n.watchCallback&&(s.$watchers$=r.watchers),tt(r,s,2),r.isProxied=!0);let l=I("createInstance",s.$tagName$);n.member&&(t.$flags$|=8);try{new r(t)}catch($){N($)}n.member&&(t.$flags$&=-9),n.watchCallback&&(t.$flags$|=128),l(),ce(t.$lazyInstance$)}else r=e.constructor,customElements.whenDefined(s.$tagName$).then(()=>t.$flags$|=128);if(n.style&&r.style){let l=r.style;n.mode&&typeof l!="string"&&(l=l[t.$modeName$=Rt(e)],n.hydrateServerSide&&t.$modeName$&&e.setAttribute("s-mode",t.$modeName$));let $=He(s,t.$modeName$);if(!X.has($)){let d=I("registerStyles",s.$tagName$);!n.hydrateServerSide&&n.shadowDom&&n.shadowDomShim&&s.$flags$&8&&(l=yield import("./chunk-GRRWJTMH.js").then(f=>f.scopeCss(l,$,!1))),jt($,l,!!(s.$flags$&1)),d()}}}let i=t.$ancestorComponent$,a=()=>me(t,!0);n.asyncLoading&&i&&i["s-rc"]?i["s-rc"].push(a):a()}),ce=e=>{n.lazyLoad&&n.connectedCallback&&D(e,"connectedCallback")},Zt=e=>{if(!(h.$flags$&1)){let t=x(e),s=t.$cmpMeta$,o=I("connectedCallback",s.$tagName$);if(n.hostListenerTargetParent&&de(e,t,s.$listeners$,!0),t.$flags$&1)de(e,t,s.$listeners$,!1),t!=null&&t.$lazyInstance$?ce(t.$lazyInstance$):t!=null&&t.$onReadyPromise$&&t.$onReadyPromise$.then(()=>ce(t.$lazyInstance$));else{t.$flags$|=1;let r;if(n.hydrateClientSide&&(r=e.getAttribute(ne),r)){if(n.shadowDom&&_&&s.$flags$&1){let i=n.mode?ae(e.shadowRoot,s,e.getAttribute("s-mode")):ae(e.shadowRoot,s);e.classList.remove(i+"-h",i+"-s")}Ut(e,s.$tagName$,r,t)}if(n.slotRelocation&&!r&&(n.hydrateServerSide||(n.slot||n.shadowDom)&&s.$flags$&12)&&Vt(e),n.asyncLoading){let i=e;for(;i=i.parentNode||i.host;)if(n.hydrateClientSide&&i.nodeType===1&&i.hasAttribute("s-id")&&i["s-p"]||i["s-p"]){Ze(t,t.$ancestorComponent$=i);break}}n.prop&&!n.hydrateServerSide&&s.$members$&&Object.entries(s.$members$).map(([i,[a]])=>{if(a&31&&e.hasOwnProperty(i)){let c=e[i];delete e[i],e[i]=c}}),n.initializeNextTick?Z(()=>Re(e,t,s)):Re(e,t,s)}o()}},Vt=e=>{let t=e["s-cr"]=v.createComment(n.isDebug?`content-ref (host=${e.localName})`:"");t["s-cn"]=!0,L(e,t,e.firstChild)},V=e=>{n.lazyLoad&&n.disconnectedCallback&&D(e,"disconnectedCallback"),n.cmpDidUnload&&D(e,"componentDidUnload")},es=e=>P(void 0,null,function*(){if(!(h.$flags$&1)){let t=x(e);n.hostListener&&t.$rmListeners$&&(t.$rmListeners$.map(s=>s()),t.$rmListeners$=void 0),n.lazyLoad?t!=null&&t.$lazyInstance$?V(t.$lazyInstance$):t!=null&&t.$onReadyPromise$&&t.$onReadyPromise$.then(()=>V(t.$lazyInstance$)):V(e)}}),ts=(e,t)=>{st(e),nt(e),os(e),ns(e),as(e),rs(e),is(e),ot(e),rt(e,t),ss(e)},st=e=>{let t=e.cloneNode;e.cloneNode=function(s){let o=this,r=n.shadowDom?o.shadowRoot&&_:!1,i=t.call(o,r?s:!1);if(n.slot&&!r&&s){let a=0,c,l,$=["s-id","s-cr","s-lr","s-rc","s-sc","s-p","s-cn","s-sr","s-sn","s-hn","s-ol","s-nr","s-si","s-rf","s-rsc"];for(;a<o.childNodes.length;a++)c=o.childNodes[a]["s-nr"],l=$.every(d=>!o.childNodes[a][d]),c&&(n.appendChildSlotFix&&i.__appendChild?i.__appendChild(c.cloneNode(!0)):i.appendChild(c.cloneNode(!0))),l&&i.appendChild(o.childNodes[a].cloneNode(!0))}return i}},nt=e=>{e.__appendChild=e.appendChild,e.appendChild=function(t){let s=t["s-sn"]=it(t),o=B(this.childNodes,s,this.tagName);if(o){let r=ve(o,s),i=r[r.length-1],a=L(i.parentNode,t,i.nextSibling);return J(this),a}return this.__appendChild(t)}},ss=e=>{e.__removeChild=e.removeChild,e.removeChild=function(t){if(t&&typeof t["s-sn"]<"u"){let s=B(this.childNodes,t["s-sn"],this.tagName);if(s){let r=ve(s,t["s-sn"]).find(i=>i===t);if(r){r.remove(),J(this);return}}}return this.__removeChild(t)}},ns=e=>{let t=e.prepend;e.prepend=function(...s){s.forEach(o=>{typeof o=="string"&&(o=this.ownerDocument.createTextNode(o));let r=o["s-sn"]=it(o),i=B(this.childNodes,r,this.tagName);if(i){let a=document.createTextNode("");a["s-nr"]=o,i["s-cr"].parentNode.__appendChild(a),o["s-ol"]=a;let l=ve(i,r)[0];return L(l.parentNode,o,l.nextSibling)}return o.nodeType===1&&o.getAttribute("slot")&&(o.hidden=!0),t.call(this,o)})}},os=e=>{e.append=function(...t){t.forEach(s=>{typeof s=="string"&&(s=this.ownerDocument.createTextNode(s)),this.appendChild(s)})}},rs=e=>{let t=e.insertAdjacentHTML;e.insertAdjacentHTML=function(s,o){if(s!=="afterbegin"&&s!=="beforeend")return t.call(this,s,o);let r=this.ownerDocument.createElement("_"),i;if(r.innerHTML=o,s==="afterbegin")for(;i=r.firstChild;)this.prepend(i);else if(s==="beforeend")for(;i=r.firstChild;)this.append(i)}},is=e=>{e.insertAdjacentText=function(t,s){this.insertAdjacentHTML(t,s)}},as=e=>{let t=e.insertAdjacentElement;e.insertAdjacentElement=function(s,o){return s!=="afterbegin"&&s!=="beforeend"?t.call(this,s,o):s==="afterbegin"?(this.prepend(o),o):(s==="beforeend"&&this.append(o),o)}},ot=e=>{let t=Object.getOwnPropertyDescriptor(Node.prototype,"textContent");Object.defineProperty(e,"__textContent",t),n.experimentalScopedSlotChanges?Object.defineProperty(e,"textContent",{get(){return" "+$e(this.childNodes).map(r=>{var i,a;let c=[],l=r.nextSibling;for(;l&&l["s-sn"]===r["s-sn"];)(l.nodeType===3||l.nodeType===1)&&c.push((a=(i=l.textContent)==null?void 0:i.trim())!=null?a:""),l=l.nextSibling;return c.filter($=>$!=="").join(" ")}).filter(r=>r!=="").join(" ")+" "},set(s){$e(this.childNodes).forEach(r=>{let i=r.nextSibling;for(;i&&i["s-sn"]===r["s-sn"];){let a=i;i=i.nextSibling,a.remove()}if(r["s-sn"]===""){let a=this.ownerDocument.createTextNode(s);a["s-sn"]="",L(r.parentElement,a,r.nextSibling)}else r.remove()})}}):Object.defineProperty(e,"textContent",{get(){var s;let o=B(this.childNodes,"",this.tagName);return((s=o==null?void 0:o.nextSibling)==null?void 0:s.nodeType)===3?o.nextSibling.textContent:o?o.textContent:this.__textContent},set(s){var o;let r=B(this.childNodes,"",this.tagName);if(((o=r==null?void 0:r.nextSibling)==null?void 0:o.nodeType)===3)r.nextSibling.textContent=s;else if(r)r.textContent=s;else{this.__textContent=s;let i=this["s-cr"];i&&L(this,i,this.firstChild)}}})},rt=(e,t)=>{class s extends Array{item(r){return this[r]}}if(t.$flags$&8){let o=e.__lookupGetter__("childNodes");Object.defineProperty(e,"children",{get(){return this.childNodes.map(r=>r.nodeType===1)}}),Object.defineProperty(e,"childElementCount",{get(){return e.children.length}}),Object.defineProperty(e,"childNodes",{get(){let r=o.call(this);if(!(h.$flags$&1)&&x(this).$flags$&2){let i=new s;for(let a=0;a<r.length;a++){let c=r[a]["s-nr"];c&&i.push(c)}return i}return s.from(r)}})}},$e=e=>{let t=[];for(let s of Array.from(e))s["s-sr"]&&t.push(s),t.push(...$e(s.childNodes));return t},it=e=>e["s-sn"]||e.nodeType===1&&e.getAttribute("slot")||"",B=(e,t,s)=>{let o=0,r;for(;o<e.length;o++)if(r=e[o],r["s-sr"]&&r["s-sn"]===t&&r["s-hn"]===s||(r=B(r.childNodes,t,s),r))return r;return null},ve=(e,t)=>{let s=[e];for(;(e=e.nextSibling)&&e["s-sn"]===t;)s.push(e);return s};var Qs=(e,t)=>{let s={$flags$:t[0],$tagName$:t[1]};n.member&&(s.$members$=t[2]),n.hostListener&&(s.$listeners$=t[3]),n.watchCallback&&(s.$watchers$=e.$watchers$),n.reflect&&(s.$attrsToReflect$=[]),n.shadowDom&&!_&&s.$flags$&1&&(s.$flags$|=8),n.experimentalSlotFixes?n.scoped&&s.$flags$&2&&ts(e.prototype,s):(n.slotChildNodesFix&&rt(e.prototype,s),n.cloneNodeFix&&st(e.prototype),n.appendChildSlotFix&&nt(e.prototype),n.scopedSlotTextContentFix&&s.$flags$&2&&ot(e.prototype));let o=e.prototype.connectedCallback,r=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__registerHost(){ds(this,s)},connectedCallback(){Zt(this),n.connectedCallback&&o&&o.call(this)},disconnectedCallback(){es(this),n.disconnectedCallback&&r&&r.call(this)},__attachShadow(){_?n.shadowDelegatesFocus?this.attachShadow({mode:"open",delegatesFocus:!!(s.$flags$&16)}):this.attachShadow({mode:"open"}):this.shadowRoot=this}}),e.is=s.$tagName$,tt(e,s,3)};var de=(e,t,s,o)=>{n.hostListener&&s&&(n.hostListenerTargetParent&&(o?s=s.filter(([r])=>r&32):s=s.filter(([r])=>!(r&32))),s.map(([r,i,a])=>{let c=n.hostListenerTarget?cs(e,r):e,l=ls(t,a),$=$s(r);h.ael(c,i,l,$),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>h.rel(c,i,l,$))}))},ls=(e,t)=>s=>{try{n.lazyLoad?e.$flags$&256?e.$lazyInstance$[t](s):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,s]):e.$hostElement$[t](s)}catch(o){N(o)}},cs=(e,t)=>n.hostListenerTargetDocument&&t&4?v:n.hostListenerTargetWindow&&t&8?O:n.hostListenerTargetBody&&t&16?v.body:n.hostListenerTargetParent&&t&32?e.parentElement:e,$s=e=>ps?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0;var at=n.hotModuleReplacement?window.__STENCIL_HOSTREFS__||(window.__STENCIL_HOSTREFS__=new WeakMap):new WeakMap,x=e=>at.get(e);var ds=(e,t)=>{let s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return n.isDev&&(s.$renderCount$=0),n.method&&n.lazyLoad&&(s.$onInstancePromise$=new Promise(o=>s.$onInstanceResolve$=o)),n.asyncLoading&&(s.$onReadyPromise$=new Promise(o=>s.$onReadyResolve$=o),e["s-p"]=[],e["s-rc"]=[]),de(e,s,t.$listeners$,!1),at.set(e,s)},Be=(e,t)=>t in e,fs,N=(e,t)=>(fs||console.error)(e,t),lt=n.isTesting?["STENCIL:"]:["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"],Q=(...e)=>console.error(...lt,...e),z=(...e)=>console.warn(...lt,...e);var Oe=new Map;var us=(e,t,s)=>{let o=e.$tagName$.replace(/-/g,"_"),r=e.$lazyBundleId$;if(n.isDev&&typeof r!="string"){Q(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);return}let i=n.hotModuleReplacement?!1:Oe.get(r);if(i)return i[o];return dt(`./${r}.entry.js${n.hotModuleReplacement&&s?"?s-hmr="+s:""}`).then(a=>(n.hotModuleReplacement||Oe.set(r,a),a[o]),N)},X=new Map,ct=[],O=typeof window<"u"?window:{},v=O.document||{head:{}},Zs=O.HTMLElement||class{},h={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,o)=>e.addEventListener(t,s,o),rel:(e,t,s,o)=>e.removeEventListener(t,s,o),ce:(e,t)=>new CustomEvent(e,t)},Vs=e=>{Object.assign(h,e)},_=n.shadowDomShim&&n.shadowDom?(v.head.attachShadow+"").indexOf("[native")>-1:!0,ps=(()=>{let e=!1;try{v.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch{}return e})(),hs=e=>Promise.resolve(e),ms=n.constructableCSS?(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})():!1,ee=0,K=!1,M=[],A=[],te=[],$t=(e,t)=>s=>{e.push(s),K||(K=!0,t&&h.$flags$&4?Z(Y):h.raf(Y))},je=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){N(s)}e.length=0},ze=(e,t)=>{let s=0,o=0;for(;s<e.length&&(o=performance.now())<t;)try{e[s++](o)}catch(r){N(r)}s===e.length?e.length=0:s!==0&&e.splice(0,s)},Y=()=>{if(n.asyncQueue&&ee++,je(M),n.asyncQueue){let e=(h.$flags$&6)===2?performance.now()+14*Math.ceil(ee*.1):1/0;ze(A,e),ze(te,e),A.length>0&&(te.push(...A),A.length=0),(K=M.length+A.length+te.length>0)?h.raf(Y):ee=0}else je(A),(K=M.length>0)&&h.raf(Y)},Z=e=>hs().then(e),en=$t(M,!1),vs=$t(A,!0);export{bs as a,Ds as b,Fe as c,At as d,_s as e,ws as f,zs as g,Qs as h,Zs as i,Vs as j,en as k,vs as l};
